name: Deploy Database Schema

on:
  push:
    branches: [main]
    paths:
      - 'infrastructure/database/**'
      - '.github/workflows/deploy-database.yml'
  pull_request:
    branches: [main]
    paths:
      - 'infrastructure/database/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod

env:
  AWS_REGION: us-east-1
  TERRAFORM_VERSION: '1.5.0'

jobs:
  validate:
    name: Validate Database Schema
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Validate SQL schema
        working-directory: ./infrastructure/database
        run: |
          echo "üîç Validating database schema files..."
          
          # Check if required files exist
          test -f "schemas/business_ideas_schema.sql" || { echo "‚ùå business_ideas_schema.sql missing"; exit 1; }
          test -f "deploy-schema.sh" || { echo "‚ùå deploy-schema.sh missing"; exit 1; }
          test -f "seed-sample-data.sql" || { echo "‚ùå seed-sample-data.sql missing"; exit 1; }
          
          # Basic SQL validation
          if command -v psql &> /dev/null; then
            echo "üìã Running basic SQL syntax validation..."
            # psql -f schemas/business_ideas_schema.sql --dry-run 2>/dev/null || echo "‚ö†Ô∏è SQL syntax check not available without PostgreSQL client"
          fi
          
          # Check script permissions
          test -x "deploy-schema.sh" || { echo "‚ùå deploy-schema.sh not executable"; exit 1; }
          
          echo "‚úÖ All database schema files validated"

  plan:
    name: Plan Database Changes  
    runs-on: ubuntu-latest
    needs: validate
    if: github.event_name == 'pull_request'
    permissions:
      id-token: write
      contents: read
      pull-requests: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
          
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_GITHUB_ACTIONS_ROLE_ARN }}
          role-session-name: GitHubActions-DatabaseDeployment
          aws-region: ${{ env.AWS_REGION }}
          
      - name: Check Infrastructure Status
        working-directory: ./infrastructure/terraform/environments/dev
        run: |
          echo "üîç Checking current infrastructure status..."
          terraform init
          
          # Check if Aurora database exists and get clean output
          if terraform output rds_cluster_endpoint &>/dev/null; then
            echo "‚úÖ Aurora PostgreSQL cluster found"
            
            # Get clean terraform outputs without ANSI codes
            DB_ENDPOINT=$(terraform output -raw rds_cluster_endpoint 2>/dev/null | tr -d '\n\r' | sed 's/[[:space:]]*$//')
            DB_PORT=$(terraform output -raw rds_cluster_port 2>/dev/null | tr -d '\n\r' | sed 's/[[:space:]]*$//')
            DB_NAME=$(terraform output -raw rds_database_name 2>/dev/null | tr -d '\n\r' | sed 's/[[:space:]]*$//')
            
            # Validate outputs are not empty
            if [[ -n "$DB_ENDPOINT" && -n "$DB_PORT" && -n "$DB_NAME" ]]; then
              echo "DB_ENDPOINT=$DB_ENDPOINT" >> $GITHUB_ENV
              echo "DB_PORT=$DB_PORT" >> $GITHUB_ENV  
              echo "DB_NAME=$DB_NAME" >> $GITHUB_ENV
              echo "‚úÖ Database connection details saved to environment"
            else
              echo "‚ùå Failed to retrieve database connection details"
              exit 1
            fi
          else
            echo "‚ùå Aurora PostgreSQL cluster not found - infrastructure needs deployment first"
            exit 1
          fi
          
      - name: Generate Schema Deployment Plan
        working-directory: ./infrastructure/database
        run: |
          echo "üìã Database Schema Deployment Plan" > deployment-plan.md
          echo "=================================" >> deployment-plan.md
          echo "" >> deployment-plan.md
          echo "**Database Endpoint**: $DB_ENDPOINT" >> deployment-plan.md
          echo "**Environment**: dev" >> deployment-plan.md
          echo "**Schema Version**: $(date +%Y%m%d-%H%M%S)" >> deployment-plan.md
          echo "" >> deployment-plan.md
          echo "### Changes to be deployed:" >> deployment-plan.md
          echo "- business_ideas table with JSONB storage" >> deployment-plan.md
          echo "- Performance indexes (GIN, B-tree)" >> deployment-plan.md
          echo "- Helper functions for queries" >> deployment-plan.md
          echo "- Sample data insertion" >> deployment-plan.md
          echo "" >> deployment-plan.md
          echo "### Safety measures:" >> deployment-plan.md
          echo "- Schema backup before deployment" >> deployment-plan.md
          echo "- Transaction rollback on failure" >> deployment-plan.md
          echo "- Verification checks post-deployment" >> deployment-plan.md
          
      - name: Comment PR with deployment plan
        uses: actions/github-script@v7
        if: github.event_name == 'pull_request'
        with:
          script: |
            const fs = require('fs');
            const plan = fs.readFileSync('./infrastructure/database/deployment-plan.md', 'utf8');
            const body = `## üóÑÔ∏è Database Schema Deployment Plan
            
            ${plan}
            
            ### üöÄ Deployment Command
            The schema will be deployed using:
            \`\`\`bash
            ./infrastructure/database/deploy-schema.sh
            \`\`\`
            
            - **Workflow**: ${{ github.workflow }}
            - **Run**: ${{ github.run_number }}
            `;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });

  deploy:
    name: Deploy Database Schema
    runs-on: ubuntu-latest
    needs: validate
    if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
    permissions:
      id-token: write
      contents: read
    
    environment: ${{ github.event.inputs.environment || 'dev' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
          
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false
          
      - name: Install PostgreSQL client
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client jq
          
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_GITHUB_ACTIONS_ROLE_ARN }}
          role-session-name: GitHubActions-DatabaseDeployment
          aws-region: ${{ env.AWS_REGION }}
          
      - name: Deploy Infrastructure if Missing
        working-directory: ./infrastructure/terraform/environments/${{ github.event.inputs.environment || 'dev' }}
        env:
          TF_IN_AUTOMATION: true
          TF_CLI_ARGS: "-no-color"
        run: |
          echo "üîç Checking and deploying infrastructure as needed..."
          terraform init -no-color
          
          # Check if Aurora database exists
          DB_CHECK=$(terraform output -raw rds_cluster_endpoint 2>&1 || true)
          
          if [[ "$DB_CHECK" == *"No outputs found"* ]] || [[ "$DB_CHECK" == *"Warning:"* ]] || [[ -z "$DB_CHECK" ]]; then
            echo "‚ö†Ô∏è Aurora PostgreSQL infrastructure not found - deploying now..."
            
            # Handle potential resource conflicts with existing AWS resources
            echo "üîß Checking for existing resources and handling state drift..."
            
            # Deploy with refresh to handle existing resources
            terraform apply -target=module.postgresql_cluster -auto-approve -no-color -refresh=true
            
            # If deployment fails due to existing resources, try to import them
            if [ $? -ne 0 ]; then
              echo "‚ö†Ô∏è Deployment failed, likely due to existing resources. Attempting to import..."
              
              # Try to import existing resources (ignore failures)
              terraform import -ignore-missing-config module.postgresql_cluster.aws_secretsmanager_secret.db_credentials "arn:aws:secretsmanager:us-east-1:519284856023:secret:ai-business-factory-db-dev-credentials-iFQoGn" || true
              terraform import -ignore-missing-config module.postgresql_cluster.aws_db_subnet_group.default[0] "ai-business-factory-db-dev-subnet-group" || true  
              terraform import -ignore-missing-config module.postgresql_cluster.aws_security_group.rds[0] "sg-089fe5cc28dc8d927" || true
              terraform import -ignore-missing-config module.postgresql_cluster.aws_cloudwatch_log_group.postgresql "/aws/rds/cluster/ai-business-factory-db-dev/postgresql" || true
              
              # Retry deployment after import
              terraform apply -target=module.postgresql_cluster -auto-approve -no-color -refresh=true
            fi
            
            echo "‚úÖ Infrastructure deployment completed"
          else
            echo "‚úÖ Aurora PostgreSQL infrastructure already exists"
            echo "Endpoint: $DB_CHECK"
          fi
          
      - name: Verify Infrastructure
        working-directory: ./infrastructure/terraform/environments/${{ github.event.inputs.environment || 'dev' }}
        run: |
          echo "üîç Verifying infrastructure is ready..."
          
          # Get database connection details with ANSI codes stripped
          DB_ENDPOINT=$(terraform output -raw rds_cluster_endpoint 2>/dev/null | sed 's/\x1b\[[0-9;]*m//g' | tr -d '\n\r' || echo "")
          DB_PORT=$(terraform output -raw rds_cluster_port 2>/dev/null | sed 's/\x1b\[[0-9;]*m//g' | tr -d '\n\r' || echo "5432")
          DB_NAME=$(terraform output -raw rds_database_name 2>/dev/null | sed 's/\x1b\[[0-9;]*m//g' | tr -d '\n\r' || echo "ai_business_factory")
          
          if [ -z "$DB_ENDPOINT" ]; then
            echo "‚ùå Database endpoint not found after deployment"
            exit 1
          fi
          
          echo "‚úÖ Database infrastructure verified"
          echo "DB_ENDPOINT=$DB_ENDPOINT" >> $GITHUB_ENV
          echo "DB_PORT=$DB_PORT" >> $GITHUB_ENV
          echo "DB_NAME=$DB_NAME" >> $GITHUB_ENV
          
          # Also get username for schema deployment
          DB_USERNAME=$(terraform output -raw rds_master_username 2>/dev/null | sed 's/\x1b\[[0-9;]*m//g' | tr -d '\n\r' || echo "postgres")
          echo "DB_USERNAME=$DB_USERNAME" >> $GITHUB_ENV
          
      - name: Deploy Database Schema
        working-directory: ./infrastructure/database
        env:
          DB_ENDPOINT: ${{ env.DB_ENDPOINT }}
          DB_PORT: ${{ env.DB_PORT }}
          DB_NAME: ${{ env.DB_NAME }}
          DB_USERNAME: ${{ env.DB_USERNAME }}
          SECRET_ARN: ${{ env.SECRET_ARN }}
        run: |
          echo "üöÄ Deploying database schema..."
          
          # Get secret ARN from terraform
          cd ../terraform/environments/${{ github.event.inputs.environment || 'dev' }}
          SECRET_ARN=$(terraform output -raw rds_master_password_secret_arn 2>/dev/null | sed 's/\x1b\[[0-9;]*m//g' | tr -d '\n\r')
          export SECRET_ARN
          
          cd ../../../database
          
          # Make script executable
          chmod +x deploy-schema.sh
          
          # Run deployment script
          ./deploy-schema.sh
          
          echo "‚úÖ Database schema deployment completed"
          
      - name: Verify Deployment
        working-directory: ./infrastructure/terraform/environments/${{ github.event.inputs.environment || 'dev' }}
        run: |
          echo "üß™ Verifying schema deployment..."
          
          # Get database connection details
          DB_ENDPOINT=$(terraform output -raw rds_cluster_endpoint)
          DB_USERNAME=$(terraform output -raw rds_master_username)
          SECRET_ARN=$(terraform output -raw rds_master_password_secret_arn)
          
          # Get password from secrets manager
          DB_PASSWORD=$(aws secretsmanager get-secret-value --secret-id "$SECRET_ARN" --query SecretString --output text | jq -r .password)
          
          # Test connection and verify tables
          CONNECTION_STRING="postgresql://${DB_USERNAME}:${DB_PASSWORD}@${DB_ENDPOINT}:${DB_PORT}/${DB_NAME}?sslmode=require"
          
          echo "Testing database connection..."
          psql "$CONNECTION_STRING" -c "SELECT version();" > /dev/null
          
          echo "Verifying business_ideas table..."
          TABLE_EXISTS=$(psql "$CONNECTION_STRING" -t -c "SELECT EXISTS (SELECT FROM information_schema.tables WHERE table_name = 'business_ideas');")
          
          if [[ "$TABLE_EXISTS" =~ "t" ]]; then
            echo "‚úÖ business_ideas table verified"
          else
            echo "‚ùå business_ideas table not found"
            exit 1
          fi
          
          echo "Checking indexes..."
          INDEX_COUNT=$(psql "$CONNECTION_STRING" -t -c "SELECT COUNT(*) FROM pg_indexes WHERE tablename = 'business_ideas';")
          echo "‚úÖ Created $INDEX_COUNT indexes on business_ideas table"
          
      - name: Seed Sample Data (Optional)
        working-directory: ./infrastructure/database
        run: |
          echo "üå± Seeding sample data..."
          
          # Get connection details  
          cd ../terraform/environments/${{ github.event.inputs.environment || 'dev' }}
          DB_ENDPOINT=$(terraform output -raw rds_cluster_endpoint)
          DB_USERNAME=$(terraform output -raw rds_master_username)
          SECRET_ARN=$(terraform output -raw rds_master_password_secret_arn)
          DB_PASSWORD=$(aws secretsmanager get-secret-value --secret-id "$SECRET_ARN" --query SecretString --output text | jq -r .password)
          
          CONNECTION_STRING="postgresql://${DB_USERNAME}:${DB_PASSWORD}@${DB_ENDPOINT}:${DB_PORT}/${DB_NAME}?sslmode=require"
          
          cd ../../../database
          
          # Only seed if table is empty
          RECORD_COUNT=$(psql "$CONNECTION_STRING" -t -c "SELECT COUNT(*) FROM business_ideas;")
          
          if [ "$RECORD_COUNT" -eq 0 ]; then
            echo "üìù Inserting sample data..."
            psql "$CONNECTION_STRING" -f seed-sample-data.sql
            echo "‚úÖ Sample data inserted"
          else
            echo "‚ÑπÔ∏è Table already has $RECORD_COUNT records, skipping sample data"
          fi
          
      - name: Generate Deployment Summary
        id: summary
        working-directory: ./infrastructure/terraform/environments/${{ github.event.inputs.environment || 'dev' }}
        run: |
          echo "üìä Generating deployment summary..."
          
          DB_ENDPOINT=$(terraform output -raw rds_cluster_endpoint)
          ENVIRONMENT="${{ github.event.inputs.environment || 'dev' }}"
          
          echo "deployment_summary<<EOF" >> $GITHUB_OUTPUT
          echo "## üóÑÔ∏è Database Schema Deployment Summary" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_OUTPUT
          echo "**Status**: ‚úÖ Deployed Successfully" >> $GITHUB_OUTPUT
          echo "**Environment**: \`$ENVIRONMENT\`" >> $GITHUB_OUTPUT
          echo "**Database**: \`$DB_ENDPOINT\`" >> $GITHUB_OUTPUT
          echo "**Schema Version**: $(date +%Y%m%d-%H%M%S)" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_OUTPUT
          echo "### üìã Deployed Components" >> $GITHUB_OUTPUT
          echo "- ‚úÖ business_ideas table with JSONB storage" >> $GITHUB_OUTPUT
          echo "- ‚úÖ Performance indexes (GIN, B-tree, full-text)" >> $GITHUB_OUTPUT
          echo "- ‚úÖ Helper functions for CRUD operations" >> $GITHUB_OUTPUT
          echo "- ‚úÖ Sample data (3 comprehensive business ideas)" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_OUTPUT
          echo "### üîó Next Steps" >> $GITHUB_OUTPUT
          echo "1. Implement CRUD API endpoints for business ideas" >> $GITHUB_OUTPUT
          echo "2. Update AI orchestrator to persist analysis results" >> $GITHUB_OUTPUT
          echo "3. Connect Ideas PWA to database queries" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_OUTPUT
          echo "**Workflow**: ${{ github.workflow }} #${{ github.run_number }}" >> $GITHUB_OUTPUT
          echo "**Commit**: ${{ github.sha }}" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
      - name: Update deployment status
        uses: actions/github-script@v7
        with:
          script: |
            const summary = `${{ steps.summary.outputs.deployment_summary }}`;
            console.log(summary);

  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [validate, deploy]
    if: always() && (needs.deploy.result == 'success' || needs.deploy.result == 'failure')
    
    steps:
      - name: Deployment Success Notification
        if: needs.deploy.result == 'success'
        run: |
          echo "üéâ Database schema deployment completed successfully!"
          echo "PostgreSQL JSONB storage is now ready for AI-generated business ideas."
          
      - name: Deployment Failure Notification
        if: needs.deploy.result == 'failure'
        run: |
          echo "‚ùå Database schema deployment failed!"
          echo "Please check the workflow logs and database connection details."
          exit 1